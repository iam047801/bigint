package bigint

import (
	"fmt"

	"database/sql"
	"database/sql/driver"

	"math/big"
)

// forked from https://github.com/d-fal/bigint

type BigInt big.Int

// FromBigInt is a shortcut for (*BigInt)(x).
func FromBigInt(x *big.Int) *BigInt {
	return (*BigInt)(x)
}

// ToBigInt is a shortcut for (*big.Int)(x).
func (x *BigInt) ToBigInt() *big.Int {
	return (*big.Int)(x)
}

// FromInt64 allocates and returns a new BigInt set to x.
func FromInt64(x int64) *BigInt {
	return FromBigInt(big.NewInt(x))
}

// FromString allocates and returns a new BigInt set to x, interpreted in the base 10.
func FromString(x string) (*BigInt, error) {
	a := big.NewInt(0)
	b, ok := a.SetString(x, 10)

	if !ok {
		return nil, fmt.Errorf("cannot create BigInt from string")
	}

	return FromBigInt(b), nil
}

// Value returns string representation of BigInt.
func (x *BigInt) Value() (driver.Value, error) {
	return (*big.Int)(x).String(), nil
}

// Scan maps value to BigInt.
func (x *BigInt) Scan(value interface{}) error {
	var i sql.NullString

	if err := i.Scan(value); err != nil {
		return err
	}

	if _, ok := (*big.Int)(x).SetString(i.String, 10); ok {
		return nil
	}

	return fmt.Errorf("error converting type %T into BigInt", value)
}

func (b BigInt) MarshalJSON() ([]byte, error) {
    return []byte(b.String()), nil
}

func (b *BigInt) UnmarshalJSON(p []byte) error {
    if string(p) == "null" {
        return nil
    }
    var z big.Int
    _, ok := z.SetString(string(p), 10)
    if !ok {
        return fmt.Errorf("not a valid big integer: %s", p)
    }
    b.Int = z
    return nil
}

// Sub sets new BigInt to the difference x-y and returns it.
func (x *BigInt) Sub(y *BigInt) *BigInt {
	return (*BigInt)(big.NewInt(0).Sub(x.ToBigInt(), y.ToBigInt()))
}

// Add sets new BigInt to the sum x+y and returns it.
func (x *BigInt) Add(y *BigInt) *BigInt {
	return (*BigInt)(big.NewInt(0).Add(x.ToBigInt(), y.ToBigInt()))
}

// Mul sets new BigInt to the product x*y and returns it.
func (x *BigInt) Mul(y *BigInt) *BigInt {
	return (*BigInt)(big.NewInt(0).Mul(x.ToBigInt(), y.ToBigInt()))
}

// Div sets new BigInt to the quotient x/y for y != 0 and returns it.
// If y == 0, a division-by-zero run-time panic occurs.
func (x *BigInt) Div(y *BigInt) *BigInt {
	return (*BigInt)(big.NewInt(0).Div(x.ToBigInt(), y.ToBigInt()))
}

// Neg sets new BigInt to -x and returns it.
func (x *BigInt) Neg() *BigInt {
	return (*BigInt)(big.NewInt(0).Neg(x.ToBigInt()))
}

// Cmp compares x and y and returns:
//
//   -1 if x <  y
//    0 if x == y
//   +1 if x >  y
//
func (x *BigInt) Cmp(y *BigInt) int {
	return x.ToBigInt().Cmp(y.ToBigInt())
}

// ToUInt64 returns the uint64 representation of x.
// If x cannot be represented in a uint64, the result is undefined.
func (x *BigInt) ToUInt64() uint64 {
	return x.ToBigInt().Uint64()
}

// ToInt64 returns the int64 representation of x.
// If x cannot be represented in an int64, the result is undefined.
func (x *BigInt) ToInt64() int64 {
	return x.ToBigInt().Int64()
}

// String returns the decimal representation of x as generated by x.ToBigInt().Text(10).
func (x *BigInt) String() string {
	return x.ToBigInt().String()
}

// Bytes returns the absolute value of x as a big-endian byte slice.
//
// To use a fixed length slice, or a preallocated one, use FillBytes.
func (x *BigInt) Bytes() []byte {
	return x.ToBigInt().Bytes()
}
